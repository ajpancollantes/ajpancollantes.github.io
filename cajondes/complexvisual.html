<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holomorphic Function Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #1a202c; /* Equivalent to dark gray bg-gray-800 */
            border-radius: 0.5rem;
            touch-action: none;
        }
        .label {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.25rem 0.75rem;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col h-screen">
    <!-- Header -->
    <header class="bg-gray-800 shadow-md p-4">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <h1 class="text-2xl font-bold text-white mb-4 sm:mb-0">Holomorphic Function Visualizer</h1>
            <div class="mt-4 sm:mt-0 flex flex-col sm:flex-row sm:items-center gap-4">
                <!-- Grid Density Slider -->
                <div class="flex items-center">
                     <label for="grid-slider" class="mr-3 font-medium whitespace-nowrap">Grid Size:</label>
                     <input id="grid-slider" type="range" min="10" max="80" value="20" class="w-32 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                     <span id="grid-value" class="ml-3 text-cyan-400 font-mono w-8">20</span>
                </div>
                <!-- Function Selector -->
                <div class="flex items-center">
                    <label for="function-select" class="mr-3 font-medium">Function f(z):</label>
                    <select id="function-select" class="bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:ring-cyan-500 focus:border-cyan-500">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                 <button id="reset-view-btn" class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Reset View</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-4 grid grid-cols-1 md:grid-cols-2 gap-6" id="canvas-container">
        <!-- Domain Panel -->
        <div class="relative rounded-lg shadow-lg">
            <canvas id="domain-canvas"></canvas>
            <div class="label text-white">Domain (z-plane)</div>
        </div>
        <!-- Image Panel -->
        <div class="relative rounded-lg shadow-lg">
            <canvas id="image-canvas"></canvas>
            <div class="label text-white">Image (w-plane)</div>
        </div>
    </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Canvas and Context Setup ---
    const domainCanvas = document.getElementById('domain-canvas');
    const imageCanvas = document.getElementById('image-canvas');
    const domainCtx = domainCanvas.getContext('2d');
    const imageCtx = imageCanvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    // --- Complex Number Utilities ---
    // Represents a complex number z = re + i*im
    const C = (re, im) => ({ re, im });

    const add = (z1, z2) => C(z1.re + z2.re, z1.im + z2.im);
    const sub = (z1, z2) => C(z1.re - z2.re, z1.im - z2.im);
    const mul = (z1, z2) => C(z1.re * z2.re - z1.im * z2.im, z1.re * z2.im + z1.im * z2.re);
    const inv = (z) => {
        const d = z.re * z.re + z.im * z.im;
        if (d === 0) return C(Infinity, Infinity);
        return C(z.re / d, -z.im / d);
    };
    const conj = (z) => C(z.re, -z.im);
    const exp = (z) => {
        const factor = Math.exp(z.re);
        return C(factor * Math.cos(z.im), factor * Math.sin(z.im));
    };
    const pow = (z, n) => {
        let result = C(1, 0);
        for (let i = 0; i < n; i++) {
            result = mul(result, z);
        }
        return result;
    };
    const log = (z) => {
        const mag = Math.sqrt(z.re * z.re + z.im * z.im);
        if (mag === 0) return C(-Infinity, 0); // log(0) is undefined, maps to -infinity
        const arg = Math.atan2(z.im, z.re);
        return C(Math.log(mag), arg);
    };

    // --- Configuration ---
    let gridDensity = 20; // Will be controlled by a slider
    const DOMAIN_MIN = -2;
    const DOMAIN_MAX = 2;
    let image_view = {
        center: C(0, 0),
        width: 8
    };

    const COLORS = {
        grid: 'rgba(100, 116, 139, 0.4)',
        highlight: '#38bdf8', // light blue
        fill: 'rgba(56, 189, 248, 0.3)',
    };
    
    let gridData = [];
    let highlightedCellIndex = -1;
    let currentFunction;
    
    // State for panning and zooming
    let isPanning = false;
    let lastMousePos = { x: 0, y: 0 };
    
    // --- Function Definitions ---
    const functions = {
        'f(z) = z (Identity)': { func: z => z, holomorphic: true },
        'f(z) = z² (Holomorphic)': { func: z => pow(z, 2), holomorphic: true },
        'f(z) = z³ (Holomorphic)': { func: z => pow(z, 3), holomorphic: true },
        'f(z) = exp(z) (Holomorphic)': { func: z => exp(z), holomorphic: true },
        'f(z) = log(z) (Holomorphic)': { func: z => log(z), holomorphic: true },
        'f(z) = 1/z (Holomorphic)': { func: z => inv(z), holomorphic: true },
        'f(z) = conj(z) (Not Holomorphic)': { func: z => conj(z), holomorphic: false },
        'f(z) = z + Im(z) (Constant Shear)': { func: z => C(z.re + z.im, z.im), holomorphic: false },
        'f(z) = x+y² + iy (Variable Shear)': { func: z => C(z.re + z.im * z.im, z.im), holomorphic: false },
        'f(z) = Re(z) (Not Holomorphic)': { func: z => C(z.re, 0), holomorphic: false },
        'f(z) = z + conj(z) (Not Holomorphic)': { func: z => add(z, conj(z)), holomorphic: false },
        'f(z) = z * conj(z) (Not Holomorphic)': { func: z => mul(z, conj(z)), holomorphic: false }
    };

    // --- Coordinate Transformation ---
    const mapToCanvas = (val, min, max, canvasSize) => {
        return ((val - min) / (max - min)) * canvasSize;
    };
    
    const mapPointToCanvas = (z, view_center, view_width, canvas) => {
        const view_height = view_width * (canvas.height / canvas.width);
        const re_min = view_center.re - view_width / 2;
        const re_max = view_center.re + view_width / 2;
        const im_min = view_center.im - view_height / 2;
        const im_max = view_center.im + view_height / 2;

        return {
            x: mapToCanvas(z.re, re_min, re_max, canvas.width),
            // The y-axis is inverted in canvas vs complex plane.
            // So we map the z.im value from a reversed range [im_max, im_min].
            y: mapToCanvas(z.im, im_max, im_min, canvas.height)
        };
    };
    
    const mapCanvasToPoint = (px, py, view_center, view_width, canvas) => {
        const view_height = view_width * (canvas.height / canvas.width);
        const re_min = view_center.re - view_width / 2;
        const im_max = view_center.im + view_height / 2;
        
        const re = (px / canvas.width) * view_width + re_min;
        const im = im_max - (py / canvas.height) * view_height; // Reverse the mapping
        return C(re, im);
    };

    // --- Core Logic ---
    function generateGrid() {
        gridData = [];
        const step = (DOMAIN_MAX - DOMAIN_MIN) / gridDensity;
        for (let i = 0; i < gridDensity; i++) {
            for (let j = 0; j < gridDensity; j++) {
                const re = DOMAIN_MIN + i * step;
                const im = DOMAIN_MIN + j * step;
                
                const z00 = C(re, im);
                const z10 = C(re + step, im);
                const z01 = C(re, im + step);
                const z11 = C(re + step, im + step);
                
                const w00 = currentFunction.func(z00);
                const w10 = currentFunction.func(z10);
                const w01 = currentFunction.func(z01);
                const w11 = currentFunction.func(z11);
                
                gridData.push({
                    domain: [z00, z10, z11, z01],
                    image: [w00, w10, w11, w01]
                });
            }
        }
    }

    function draw() {
        // Clear canvases
        domainCtx.clearRect(0, 0, domainCanvas.width, domainCanvas.height);
        imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);

        const domain_view_width = DOMAIN_MAX - DOMAIN_MIN;
        const domain_center = C(DOMAIN_MIN + domain_view_width / 2, DOMAIN_MIN + domain_view_width / 2);

        gridData.forEach((cell, index) => {
            // Draw Domain Cell
            const domainPath = new Path2D();
            const pStart = mapPointToCanvas(cell.domain[0], domain_center, domain_view_width, domainCanvas);
            domainPath.moveTo(pStart.x, pStart.y);
            for(let i = 1; i < cell.domain.length; i++) {
                const p = mapPointToCanvas(cell.domain[i], domain_center, domain_view_width, domainCanvas);
                domainPath.lineTo(p.x, p.y);
            }
            domainPath.closePath();
            domainCtx.strokeStyle = COLORS.grid;
            domainCtx.stroke(domainPath);

            // Draw Image Cell
            const imagePath = new Path2D();
            const wStart = mapPointToCanvas(cell.image[0], image_view.center, image_view.width, imageCanvas);
            imagePath.moveTo(wStart.x, wStart.y);
            for(let i = 1; i < cell.image.length; i++) {
                const p = mapPointToCanvas(cell.image[i], image_view.center, image_view.width, imageCanvas);
                // Prevent drawing if values are infinite
                if (isFinite(p.x) && isFinite(p.y)) {
                    imagePath.lineTo(p.x, p.y);
                } else {
                    // If we encounter infinity, we just move to the next valid point
                    const nextValid = cell.image.slice(i).find(pt => isFinite(pt.re) && isFinite(pt.im));
                    if(nextValid) {
                        const nextP = mapPointToCanvas(nextValid, image_view.center, image_view.width, imageCanvas);
                        imagePath.moveTo(nextP.x, nextP.y);
                    }
                }
            }
            imagePath.closePath();
            imageCtx.strokeStyle = COLORS.grid;
            imageCtx.stroke(imagePath);

            // Highlight
            if (index === highlightedCellIndex) {
                domainCtx.fillStyle = COLORS.fill;
                domainCtx.fill(domainPath);
                domainCtx.strokeStyle = COLORS.highlight;
                domainCtx.lineWidth = 2;
                domainCtx.stroke(domainPath);
                
                imageCtx.fillStyle = COLORS.fill;
                imageCtx.fill(imagePath);
                imageCtx.strokeStyle = COLORS.highlight;
                imageCtx.lineWidth = 2;
                imageCtx.stroke(imagePath);
                
                // Reset line width for next iterations
                domainCtx.lineWidth = 1;
                imageCtx.lineWidth = 1;
            }
        });
    }

    // --- Event Handlers ---
    function handleMouseMove(e) {
        const rect = domainCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const domain_view_width = DOMAIN_MAX - DOMAIN_MIN;
        const domain_center = C(DOMAIN_MIN + domain_view_width / 2, DOMAIN_MIN + domain_view_width / 2);
        const mousePoint = mapCanvasToPoint(x, y, domain_center, domain_view_width, domainCanvas);
        
        const step = (DOMAIN_MAX - DOMAIN_MIN) / gridDensity;
        const gridX = Math.floor((mousePoint.re - DOMAIN_MIN) / step);
        const gridY = Math.floor((mousePoint.im - DOMAIN_MIN) / step);

        let newIndex = -1;
        if (gridX >= 0 && gridX < gridDensity && gridY >= 0 && gridY < gridDensity) {
            newIndex = gridX * gridDensity + gridY;
        }

        if (newIndex !== highlightedCellIndex) {
            highlightedCellIndex = newIndex;
            requestAnimationFrame(draw);
        }
    }
    
    function handleMouseLeave() {
        if (highlightedCellIndex !== -1) {
            highlightedCellIndex = -1;
            requestAnimationFrame(draw);
        }
    }

    function handleFunctionChange() {
        const selectedKey = document.getElementById('function-select').value;
        currentFunction = functions[selectedKey];
        generateGrid();
        requestAnimationFrame(draw);
    }

    function handleGridSlider(e) {
        gridDensity = parseInt(e.target.value, 10);
        document.getElementById('grid-value').textContent = gridDensity;
        generateGrid();
        requestAnimationFrame(draw);
    }

    // --- Image Canvas Navigation Handlers ---
    function handleImageMouseDown(e) {
        isPanning = true;
        lastMousePos = { x: e.clientX, y: e.clientY };
        imageCanvas.style.cursor = 'grabbing';
    }

    function handleImageMouseUp() {
        isPanning = false;
        imageCanvas.style.cursor = 'grab';
    }

    function handleImageMouseMove(e) {
        if (!isPanning) return;
        
        const dx = e.clientX - lastMousePos.x;
        const dy = e.clientY - lastMousePos.y;

        const deltaRe = (dx / imageCanvas.width) * image_view.width;
        const deltaIm = (dy / imageCanvas.height) * (image_view.width * imageCanvas.height / imageCanvas.width);

        // Subtract deltaRe to move content with mouse horizontally.
        // Add deltaIm to move content with mouse vertically. THIS is the fix.
        image_view.center = C(image_view.center.re - deltaRe, image_view.center.im + deltaIm);

        lastMousePos = { x: e.clientX, y: e.clientY };
        requestAnimationFrame(draw);
    }
    
    function handleImageWheel(e) {
        e.preventDefault();
        const rect = imageCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const pointBeforeZoom = mapCanvasToPoint(x, y, image_view.center, image_view.width, imageCanvas);

        const zoomFactor = e.deltaY < 0 ? 0.85 : 1.15; // Zoom in or out
        image_view.width *= zoomFactor;
        
        const pointAfterZoom = mapCanvasToPoint(x, y, image_view.center, image_view.width, imageCanvas);

        const delta = sub(pointAfterZoom, pointBeforeZoom);
        image_view.center = sub(image_view.center, delta);
        
        requestAnimationFrame(draw);
    }
    
    function resetView() {
        image_view.center = C(0, 0);
        image_view.width = 8;
        requestAnimationFrame(draw);
    }


    // --- Initialization ---
    function setup() {
        // Populate dropdown
        const select = document.getElementById('function-select');
        for (const key in functions) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            select.appendChild(option);
        }
        select.addEventListener('change', handleFunctionChange);
        
        // Grid slider
        document.getElementById('grid-slider').addEventListener('input', handleGridSlider);

        // Reset button
        document.getElementById('reset-view-btn').addEventListener('click', resetView);

        // Set initial function
        currentFunction = functions[select.options[0].value];
        
        // Setup canvases
        function resizeCanvases() {
            const size = container.children[0].clientWidth;
            domainCanvas.width = size;
            domainCanvas.height = size;
            imageCanvas.width = size;
            imageCanvas.height = size;
            generateGrid();
            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Attach event listeners
        domainCanvas.addEventListener('mousemove', handleMouseMove);
        domainCanvas.addEventListener('mouseleave', handleMouseLeave);
        
        // Listeners for image canvas navigation
        imageCanvas.addEventListener('mousedown', handleImageMouseDown);
        window.addEventListener('mouseup', handleImageMouseUp); // Listen on window to catch mouseup outside canvas
        window.addEventListener('mousemove', handleImageMouseMove); // Listen on window to allow smooth panning
        imageCanvas.addEventListener('wheel', handleImageWheel);
        imageCanvas.style.cursor = 'grab';
        
    }

    setup();
});
</script>

</body>
</html>



