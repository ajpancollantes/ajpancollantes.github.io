<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holomorphic Function Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #1a202c; /* Equivalent to dark gray bg-gray-800 */
            border-radius: 0.5rem;
            touch-action: none;
        }
        .label {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.25rem 0.75rem;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col h-screen antialiased">

    <!-- Header -->
    <header class="p-4 bg-gray-800/50 backdrop-blur-sm border-b border-gray-700">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <div>
                <h1 class="text-2xl font-bold text-cyan-400">Complex Function Visualizer</h1>
                <p class="text-gray-400 mt-1">See how functions f: ℂ → ℂ transform the plane. Hover over the left grid.</p>
            </div>
            <div class="mt-4 sm:mt-0">
                <label for="function-select" class="mr-2 font-medium">Select Function f(z):</label>
                <select id="function-select" class="bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:ring-cyan-500 focus:border-cyan-500">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow container mx-auto p-4 grid grid-cols-1 md:grid-cols-2 gap-6" id="canvas-container">
        <!-- Domain Panel -->
        <div class="relative rounded-lg shadow-lg">
            <canvas id="domain-canvas"></canvas>
            <div class="label text-white">Domain (z-plane)</div>
        </div>
        <!-- Image Panel -->
        <div class="relative rounded-lg shadow-lg">
            <canvas id="image-canvas"></canvas>
            <div class="label text-white">Image (w-plane)</div>
        </div>
    </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Canvas and Context Setup ---
    const domainCanvas = document.getElementById('domain-canvas');
    const imageCanvas = document.getElementById('image-canvas');
    const domainCtx = domainCanvas.getContext('2d');
    const imageCtx = imageCanvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    // --- Configuration ---
    const GRID_DENSITY = 20; // Number of cells along one axis
    const DOMAIN_MIN = -2;
    const DOMAIN_MAX = 2;
    const IMAGE_MIN = -4;
    const IMAGE_MAX = 4;

    const COLORS = {
        grid: 'rgba(100, 116, 139, 0.4)',
        highlight: '#38bdf8', // light blue
        fill: 'rgba(56, 189, 248, 0.3)',
    };
    
    let gridData = [];
    let highlightedCellIndex = -1;
    let currentFunction;

    // --- Complex Number Utilities ---
    // Represents a complex number z = re + i*im
    const C = (re, im) => ({ re, im });

    const add = (z1, z2) => C(z1.re + z2.re, z1.im + z2.im);
    const sub = (z1, z2) => C(z1.re - z2.re, z1.im - z2.im);
    const mul = (z1, z2) => C(z1.re * z2.re - z1.im * z2.im, z1.re * z2.im + z1.im * z2.re);
    const inv = (z) => {
        const d = z.re * z.re + z.im * z.im;
        if (d === 0) return C(Infinity, Infinity);
        return C(z.re / d, -z.im / d);
    };
    const conj = (z) => C(z.re, -z.im);
    const exp = (z) => {
        const factor = Math.exp(z.re);
        return C(factor * Math.cos(z.im), factor * Math.sin(z.im));
    };
    const pow = (z, n) => {
        let result = C(1, 0);
        for (let i = 0; i < n; i++) {
            result = mul(result, z);
        }
        return result;
    };
    const log = (z) => {
        const mag = Math.sqrt(z.re * z.re + z.im * z.im);
        if (mag === 0) return C(-Infinity, 0); // log(0) is undefined, maps to -infinity
        const arg = Math.atan2(z.im, z.re);
        return C(Math.log(mag), arg);
    };
    
    // --- Function Definitions ---
    const functions = {
        'f(z) = z (Identity)': { func: z => z, holomorphic: true },
        'f(z) = z² (Holomorphic)': { func: z => pow(z, 2), holomorphic: true },
        'f(z) = z³ (Holomorphic)': { func: z => pow(z, 3), holomorphic: true },
        'f(z) = exp(z) (Holomorphic)': { func: z => exp(z), holomorphic: true },
        'f(z) = log(z) (Holomorphic)': { func: z => log(z), holomorphic: true },
        'f(z) = 1/z (Holomorphic)': { func: z => inv(z), holomorphic: true },
        'f(z) = conj(z) (Not Holomorphic)': { func: z => conj(z), holomorphic: false },
        'f(z) = z + Im(z) (Constant Shear)': { func: z => C(z.re + z.im, z.im), holomorphic: false },
        'f(z) = x+y² + iy (Variable Shear)': { func: z => C(z.re + z.im * z.im, z.im), holomorphic: false },
        'f(z) = Re(z) (Not Holomorphic)': { func: z => C(z.re, 0), holomorphic: false },
        'f(z) = z + conj(z) (Not Holomorphic)': { func: z => add(z, conj(z)), holomorphic: false },
        'f(z) = z * conj(z) (Not Holomorphic)': { func: z => mul(z, conj(z)), holomorphic: false }
    };

    // --- Coordinate Transformation ---
    const mapToCanvas = (val, min, max, canvasSize) => {
        return ((val - min) / (max - min)) * canvasSize;
    };
    
    const mapPointToCanvas = (z, min, max, canvas) => {
        return {
            x: mapToCanvas(z.re, min, max, canvas.width),
            y: mapToCanvas(-z.im, min, max, canvas.height) // Invert Y-axis for standard math coords
        };
    };
    
    const mapCanvasToPoint = (px, py, min, max, canvas) => {
        const re = (px / canvas.width) * (max - min) + min;
        const im = -((py / canvas.height) * (max - min) - max);
        return C(re, im);
    };

    // --- Core Logic ---
    function generateGrid() {
        gridData = [];
        const step = (DOMAIN_MAX - DOMAIN_MIN) / GRID_DENSITY;
        for (let i = 0; i < GRID_DENSITY; i++) {
            for (let j = 0; j < GRID_DENSITY; j++) {
                const re = DOMAIN_MIN + i * step;
                const im = DOMAIN_MIN + j * step;
                
                const z00 = C(re, im);
                const z10 = C(re + step, im);
                const z01 = C(re, im + step);
                const z11 = C(re + step, im + step);
                
                const w00 = currentFunction.func(z00);
                const w10 = currentFunction.func(z10);
                const w01 = currentFunction.func(z01);
                const w11 = currentFunction.func(z11);
                
                gridData.push({
                    domain: [z00, z10, z11, z01],
                    image: [w00, w10, w11, w01]
                });
            }
        }
    }

    function draw() {
        // Clear canvases
        domainCtx.clearRect(0, 0, domainCanvas.width, domainCanvas.height);
        imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);

        gridData.forEach((cell, index) => {
            // Draw Domain Cell
            const domainPath = new Path2D();
            const pStart = mapPointToCanvas(cell.domain[0], DOMAIN_MIN, DOMAIN_MAX, domainCanvas);
            domainPath.moveTo(pStart.x, pStart.y);
            for(let i = 1; i < cell.domain.length; i++) {
                const p = mapPointToCanvas(cell.domain[i], DOMAIN_MIN, DOMAIN_MAX, domainCanvas);
                domainPath.lineTo(p.x, p.y);
            }
            domainPath.closePath();
            domainCtx.strokeStyle = COLORS.grid;
            domainCtx.stroke(domainPath);

            // Draw Image Cell
            const imagePath = new Path2D();
            const wStart = mapPointToCanvas(cell.image[0], IMAGE_MIN, IMAGE_MAX, imageCanvas);
            imagePath.moveTo(wStart.x, wStart.y);
            for(let i = 1; i < cell.image.length; i++) {
                const p = mapPointToCanvas(cell.image[i], IMAGE_MIN, IMAGE_MAX, imageCanvas);
                // Prevent drawing if values are infinite
                if (isFinite(p.x) && isFinite(p.y)) {
                    imagePath.lineTo(p.x, p.y);
                } else {
                    // If we encounter infinity, we just move to the next valid point
                    const nextValid = cell.image.slice(i).find(pt => isFinite(pt.re) && isFinite(pt.im));
                    if(nextValid) {
                        const nextP = mapPointToCanvas(nextValid, IMAGE_MIN, IMAGE_MAX, imageCanvas);
                        imagePath.moveTo(nextP.x, nextP.y);
                    }
                }
            }
            imagePath.closePath();
            imageCtx.strokeStyle = COLORS.grid;
            imageCtx.stroke(imagePath);

            // Highlight
            if (index === highlightedCellIndex) {
                domainCtx.fillStyle = COLORS.fill;
                domainCtx.fill(domainPath);
                domainCtx.strokeStyle = COLORS.highlight;
                domainCtx.lineWidth = 2;
                domainCtx.stroke(domainPath);
                
                imageCtx.fillStyle = COLORS.fill;
                imageCtx.fill(imagePath);
                imageCtx.strokeStyle = COLORS.highlight;
                imageCtx.lineWidth = 2;
                imageCtx.stroke(imagePath);
                
                // Reset line width for next iterations
                domainCtx.lineWidth = 1;
                imageCtx.lineWidth = 1;
            }
        });
    }

    // --- Event Handlers ---
    function handleMouseMove(e) {
        const rect = domainCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const mousePoint = mapCanvasToPoint(x, y, DOMAIN_MIN, DOMAIN_MAX, domainCanvas);
        
        const step = (DOMAIN_MAX - DOMAIN_MIN) / GRID_DENSITY;
        const gridX = Math.floor((mousePoint.re - DOMAIN_MIN) / step);
        const gridY = Math.floor((mousePoint.im - DOMAIN_MIN) / step);

        let newIndex = -1;
        if (gridX >= 0 && gridX < GRID_DENSITY && gridY >= 0 && gridY < GRID_DENSITY) {
            newIndex = gridX * GRID_DENSITY + gridY;
        }

        if (newIndex !== highlightedCellIndex) {
            highlightedCellIndex = newIndex;
            requestAnimationFrame(draw);
        }
    }
    
    function handleMouseLeave() {
        if (highlightedCellIndex !== -1) {
            highlightedCellIndex = -1;
            requestAnimationFrame(draw);
        }
    }

    function handleFunctionChange() {
        const selectedKey = document.getElementById('function-select').value;
        currentFunction = functions[selectedKey];
        generateGrid();
        requestAnimationFrame(draw);
    }

    // --- Initialization ---
    function setup() {
        // Populate dropdown
        const select = document.getElementById('function-select');
        for (const key in functions) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = key;
            select.appendChild(option);
        }
        select.addEventListener('change', handleFunctionChange);

        // Set initial function
        currentFunction = functions[select.options[0].value];
        
        // Setup canvases
        function resizeCanvases() {
            const size = container.children[0].clientWidth;
            domainCanvas.width = size;
            domainCanvas.height = size;
            imageCanvas.width = size;
            imageCanvas.height = size;
            generateGrid();
            requestAnimationFrame(draw);
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Attach event listeners
        domainCanvas.addEventListener('mousemove', handleMouseMove);
        domainCanvas.addEventListener('mouseleave', handleMouseLeave);
        
    }

    setup();
});
</script>

</body>
</html>



